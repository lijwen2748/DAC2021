\section{Introduction}
In the hardware design community, model checking \cite{CGD99} has emerged as a popular technique for both bug-finding and correctness proof of hardware systems (circuits). Given a hardware design $M$ as the model and the formal specification (property) $P$, model checking checks whether $P$ holds for all behaviours of $M$. To achieve this goal, a model-checking algorithm explores the state space of $M$ by starting from the initial states to all their reachable states in $M$. Moreover, model-checking techniques terminate the exploration as soon as 1) a counterexample to represent the property violation is detected, or 2) the proof is accomplished that the initial states can never reach the states which violate the property $P$. If $P$ is a safe property, the length of the counterexample becomes finite. As a result, the safety model checking can be reduced to the reachability analysis problem \cite{KV99c}, and we focus on the safety model checking in this paper.  


Although model checking has been widely used in hardware verification, the performance improvement is still eagerly on demand to help solve more industrial instances. It is well known that no model-checking technique is the best one to dominate all others, and different algorithms perform differently for different benchmarks \cite{GR16}. Although invented in nearly three decades ago, Bounded Model Checking (BMC) \cite{BCCFZ99,BCCZ99} is still considered to be the most efficient technique for detecting bugs.  Meanwhile,  Interpolation Model Checking (IMC) \cite{McM03} and IC3 \cite{Bra11}, or Property Directed Reachability  (PDR) \cite{EMB11}, are shown more powerful to prove correctness. Therefore, a portfolio of model checking techniques is often maintained by the industry companies to solve different problems.

Recently, a new model-checking algorithm named Complementary Approximate Reachability (CAR) \cite{LZZPV17}, was proven to complement BMC on bug-findings and IC3/PDR on correctness proofs. That is, CAR is able to solve instances that BMC or IC3/PDR cannot solve within the given time and hardware sources. The achievement from CAR inspires us that, even relevant techniques have been deeply investigated for decades, there are possibilities to improve the model-checking performance such that it can be more useful for the industry. In this paper, we focus on CAR and present an improved search strategy inside the algorithm to gain a better bug-finding performance.  


CAR was inspired by IC3/PDR and the traditional reachability analysis \cite{LZZPV17}, which maintains an over-approximate state sequence for correctness proof and an under-approximate state sequence for bug-finding. CAR utilizes the depth-first search strategy to find new states that meet the constraints, which are used to refine the under-approximate state sequence, or if failed, collect the relevant  information to refine the over-approximate state sequence. The algorithm terminates as soon as either a \emph{bad} state is in the under-approximate sequence, which indicates a counterexample has been detected, or an \emph{invariant} has been computed based on the over-approximate sequence, which indicates the correctness proof has been asserted.  For more details see below. CAR can be performed in both forward and backward directions. Since evidences have shown Backward-CAR is better than Forward-CAR \cite{LDPRV18}, we follow the observation and focus on improving Backward-CAR. In the rest of the paper, all mentions of ``CAR'' represent Backward-CAR. 

Although CAR has been shown the advantage of detecting bugs for safety model checking and outperforms IC3/PDR on bug-finding, it cannot solve as many unsafe instances (those with bugs) as BMC in the current stage \cite{DLPVR19}. Looking into the state paths generated by CAR during the search, the observation comes up that, the depth-first strategy may lead the algorithm to a \emph{trap} for those unsafe cases unable to solve. As a result, to keep searching new states is almost impossible for the algorithm to locate the bad states but only wastes the computation sources. Such similar phenomenon occurs on solving the satisfiability of Boolean formulas (SAT) \cite{VWM15}, in which the search can also be in the trap if the order of variable assignments is not properly chosen. To tackle such issue, researchers propose a \emph{restart} policy such that the current search path is discarded and a new one can be selected to get rid of the trap \cite{Biere08}. Their experiments show that such simple strategy is very efficient to help speedup  SAT solving computation, particularly for those satisfiable instances. 

Inspired from the result achieved by applying the restart policy to modern SAT solvers \cite{Biere08}, we leverage the similar idea to enhance the performance of CAR on bug-finding. In our designation, the restart policy is invoked as soon as the size of new elements of the over-approximate state sequence in a single search, reaches the \emph{frequency} $k*t$ where $k$ is the length of the over-approximate sequence and $t$ is a given  \emph{threshold}, which can be dynamically updated based on a given \emph{growth rate} $gr$ during the search. That means, if the current threshold is $t$ and the growth rate is $gr$, the threshold will be updated to be $(t*gr)$ when the restart is invoked next time. Moreover, the search will be restarted next time as soon as the size of new elements of the over-approximate sequence reaches $(k*t*gr)$. As a result, the restart frequency depends on the threshold and the corresponding proportion to update it. Once the restart is triggered, CAR deletes all states information collected in the current search and start a new one immediately. 


We conduct a comprehensive experimental evaluation on  the 749 industrial instances from Hardware Model Checking Competition 2015 \cite{hwmcc15} and 2017 \cite{hwmcc17}. We implement our new algorithm based on the SimpleCAR model checker \cite{LDPRV18}\cite{simplecar}, and compare the bug-finding performance to the original CAR in SimpleCAR as well as the BMC algorithm that is implemented in the ABC model checker \cite{BM10}. The results show that, given the same time and hardware sources, CAR with the start policy can solve 18 more unsafe instances than BMC and 13 more than the original CAR, by feeding different frequencies. Although the new algorithm with a single configuration does not have a better performance than the original CAR, it does help increases the diversity to solve more instances, and therefore, increases the power of the current model-checking portfolio in the industry. 


\iffalse
Our algorithm Complementary Approximate Reachability(CAR), derived from traditional reachability analysis, is a SAT-based model checking technique that can run in two modes: forward-CAR and backward-CAR. As Backward-CAR has shown superior performance than forward-CAR in previous work, we focus on the backward-CAR and the word "CAR" will refer in particular to Backward-CAR in the following sections. The CAR algorithm maintains two sequences of abstract reachable state-sets, one is an under-approximate reachable state-sets origin from the initial states and the other is an over-approximate reachable state-sets which are generated from the bad states(the state-set violating the safety property P). 


Nowadays, a challenge in the field of hardware model checking is that the state space is too large compared to today's computing power. Due to the huge state space, a remarkably small part of the computation is used in the right place, most of the computation is just been used like looking for a needle in a haystack. A policy is needed to switch to another searching location when probably there will be no results in the current area. Previously, CAR algorithm sometimes gets stuck in a cyclical process that constantly forwarding and backtracking in certain state spaces. Inspired from the substantial effect of restart policy used in todayâ€™s clause learning SAT solvers, we apply a simple restart policy on the CAR algorithm to enhance its performance in bug-findings. We hold the opinion that the endless loop indicates it is hard to find a counterexample or a bug through this route(but not completely impossible) and the restart policy enables the algorithm to get out of the loop and then find another. 


We perform an extensive experiment based on a total of 749 industrial instances, and the results indicate that the restart policy can effectively expand the diversity of our hardware model checking algorithm: Complementary Approximate Reachability(Shorthand for the CAR). It seeks out 12 more new instances of counterexample. 

In this paper, we would like to take a step toward studying the effectiveness of applying restart policy on CAR with a view to motivating further work of designing an appropriate restart policy.
\fi
